/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.core.font{	import flash.text.Font;	import com.memento.core.system.GarbageCollector;	/**	 * STATIC Class for solving Font regarding issues with ActionScript.	 * @author Barnabás Bucsy (Lobo)	 */	public final class FontCollector	{		/**		 * General fallback Font name.		 */		public static var FALLBACK_FONT_NAME:String = '_sans';		/**		 * Container for accessable Fonts of the movie.		 */		private static var __allFonts:Object;		/**		 * Indicates whether the resolver was inited from code.		 * If not, the contents of __allFonts will be deleted.		 */		private static var __inited:Boolean = false;		/**		 * Flag for storing GarbageCollector registered status.		 */		private static var __registered:Boolean = false;		/**		 * Constructor		 * @throws Error Static Class.		 */		public function FontCollector( ):void		{			throw new Error( 'Tried to instantiate static class!' );		}		/**		 * Initializer function. Player will keep track of all		 * accessable Font names and styles if called. Handy		 * for a lot of Font name resolving.		 */		public static function init( ):void		{			if ( __inited )			{				return;			}			__init( );			__inited = true;		}		/**		 * Clears all stored data from pools.		 */		public static function dispose( ):void		{			__destroy( );			__inited = false;		}		/**		 * Private initializer function. Generates the Font		 * list used when searching.		 */		private static function __init( ):void		{			__allFonts = { };			var fonts:Array = Font.enumerateFonts( true );			var font:Font;			var j:uint = fonts.length;			for ( var i:uint = 0; i < j; i++ )			{				font = fonts[ i ];				if ( !__allFonts[ font.fontName ] )				{					__allFonts[ font.fontName ] = { };				}				__allFonts[ font.fontName ][ font.fontStyle ] = font.fontType;			}		}		/**		 * Private destroyer function. Destroys the Font		 * list.		 */		private static function __destroy( ):void		{			if ( !__allFonts )			{				return;			}			ObjectUtil.clear( __allFonts );			__allFonts = null;			if (!__registered )			{				GarbageCollector.unregister( FontCollector );				__registered = false;			}		}		/**		 * Private search function.		 * @param rest Array Desired Font names to look for.		 * @return Object An object containing possible Font names.		 */		private static function __findPossibleFonts( ...fontNames_:Array ):Object		{			if ( !__inited )			{				__init( );			}			var pattern:String;			var accuracy:Number;			var matches:Object = { };			var j:uint         = fontNames_.length;			for ( var i:uint = 0; i < j; i++ )			{				for ( var key:String in __allFonts )				{					if ( key.match( new RegExp( '^' + fontNames_[ i ], 'i' ) ) )					{						accuracy  = fontNames_[ i ].length / key.length;						accuracy += ( j - i ) / j;						if ( !matches[ key ] )						{							matches[ key ]           = __allFonts[ key ];							matches[ key ].accuracy  = accuracy;						}						else if ( matches[ key ].accuracy < accuracy )						{							matches[ key ].accuracy  = accuracy;						}					}				}			}			if ( !__registered )			{				GarbageCollector.register( FontCollector );				__registered = true;			}			return matches;		}		/**		 * Function for finding a Font name based on accessible Fonts.		 * @return String The best fit Font name.		 *		 */		public static function resolve( ...fontNames_:Array ):String		{			var possibleFonts:Object = __findPossibleFonts.apply( null, fontNames_ );			var bestFit:Number  = 0;			var fontName:String = '';			for ( var name:String in possibleFonts )			{				if ( possibleFonts[ name ].accuracy > bestFit )				{					fontName = name;					bestFit  = possibleFonts[ name ].accuracy;				}			}			if ( fontName == '' )			{				fontName = FALLBACK_FONT_NAME;			}			return fontName;		}	}}