/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.utils{	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;	import com.memento.core.system.DescribeTypeCollector;	/**	 * STATIC Class for solving Class regarding issues with ActionScript.	 * @author Barnabás Bucsy (Lobo)	 */	public class ClassUtil	{		public static const CLASS_DELIMITER:String   = '::';		public static const READ_WRITE_ACCESS:String = 'readwrite';		/**		 * Constructor		 * @throws Error Static Class.		 */		public function ClassUtil( ):void		{			throw new Error( 'Tried to instantiate static class!' );		}		/**		 * Function for retrieving class name of any ActinScript element.		 * @param value_ * Any ActinScript element.		 */		public static function getClassName( value_:* ):String		{			return getQualifiedClassName( value_ ).split( CLASS_DELIMITER ).pop( );		}		/**		 * Function for retrieving superclass name of any ActinScript element.		 * @param value_ * Any ActinScript element.		 */		public static function getSuperclassName( value_:* ):String		{			return getQualifiedSuperclassName( value_ ).split( CLASS_DELIMITER ).pop( );		}		/**		 * Function for retrieving the list of the static constants a Class has.		 * @param Class_ Class The Class to observe.		 * @return Array An Array containing the static constants' names.		 */		public static function getStaticConstantList( Class_:Class ):Array		{			var arr:Array         = [ ];			var constList:XMLList = DescribeTypeCollector.get( Class_ ).constant.attribute( 'name' );			for each ( var c:XML in constList )			{				arr.push( c.toString( ) );			}			return arr;		}		/**		 * Function for retrieving the list of the static accessors a Class has.		 * @param Class_ Class The Class to observe.		 * @return Array An Array containing the static constants' names.		 */		public static function getStaticAccessorList( Class_:Class ):Array		{			var arr:Array        = [ ];			var propList:XMLList = DescribeTypeCollector.get( Class_ ).accessor.attribute( 'name' );			for each ( var p:XML in propList )			{				arr.push( p.toString( ) );			}			return arr;		}		/**		 * Function for retrieving the list of the constants a Class has.		 * @param Class_ Class The Class to observe.		 * @return Array An Array containing the constants' names.		 */		public static function getConstantList( Class_:Class ):Array		{			var arr:Array         = [ ];			var constList:XMLList = DescribeTypeCollector.get( Class_ ).factory.constant.attribute( 'name' );			for each ( var c:XML in constList )			{				arr.push( c.toString( ) );			}			return arr;		}		/**		 * Function for returning the Class of an Object.		 * @param object_ Object An ActionScript Object to find its Class.		 * @return Class The Class of presented ActionScript Object.		 */		public static function classOf( object_:Object ):Class		{			if ( object_ is Class )			{				return object_ as Class;			}			return object_.constructor as Class;		}		/**		 * Function for determining whether two ActionScript Objects are		 * from the same Class hierarchy.		 * @param object0_ Object The Object to examine.		 * @param object1_ Object The reference Object.		 * @return Boolean Whether the two ActionScript Objects are from the same Class hierarchy.		 */		public static function conform( object0_:Object, object1_:Object ):Boolean		{			return object0_ is classOf( object1_ );		}		/**		 * Function for determining whether two ActionScript Objects are		 * from the same Class.		 * @param object0_ Object Object to examine.		 * @param object1_ Object Object to examine.		 * @return Boolean Whether the two ActionScript Objects are from the same Class.		 */		public static function sameType( object0_:Object, object1_:Object ):Boolean		{			return classOf( object0_ ) == classOf( object1_ );		}		/**		 * Tries to create a new sibling of source Object's Class.		 * @param source_ * Any type of ActionScript Object.		 * @return * Created sibling or false if creation fails.		 */		public static function newSiblingOf( source_:* ):*		{			if ( source_ )			{				var sibling:*;				try				{					sibling = new ( getDefinitionByName( getQualifiedClassName( source_ ) ) as Class )( );				}				catch ( error:Error )				{					sibling = false;				}				return sibling;			}			return false;		}		/**		 * Tries to clone source Object.		 * @param source_ * Any type of ActionScript Object.		 * @return * Created clone or false if creation fails.		 */		public static function clone( source_:* ):*		{			var clone:Object = false;			if ( source_ )			{				clone = newSiblingOf( source_ );				if ( clone )				{					synchronizePublicData( source_, clone );				}			}			return clone;		}		/**		 * Copies data from commonly named properties and getter / setter pairs.		 * @param source_ * The source to copy from.		 * @param target_ * The target to copy to.		 */		public static function synchronizePublicData( source_:*, target_:* ):Boolean		{			if ( source_ && target_ )			{				try				{					var info:XML = DescribeTypeCollector.get( source_ );					var prop:XML;					for each( prop in info.variable )					{						if ( source_.hasOwnProperty( prop.@name ) )						{							target_[ prop.@name ] = source_[ prop.@name ];						}					}					for each ( prop in info.accessor )					{						if ( prop.@access == READ_WRITE_ACCESS )						{							if ( target_.hasOwnProperty( prop.@name ) )							{								target_[ prop.@name ] = source_[ prop.@name ];							}						}					}					return true;				}				catch ( error:Error )				{					//				}			}			return false;		}	}}