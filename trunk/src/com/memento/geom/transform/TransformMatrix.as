/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.geom.transform{	import flash.geom.Point;	import flash.geom.Matrix;	import com.memento.constants.Trigonometry;	/**	 * Class for working with transformation Matrices.	 * @author Barnabás Bucsy (Lobo)	 */	public class TransformMatrix extends Matrix	{		/**		 * Constructor		 * @param matrix_ Matrix Existing matrix to use.		 */		public function TransformMatrix( matrix_:Matrix = null ):void		{			if ( matrix_ === null )			{				super( matrix_.a, matrix_.b, matrix_.c, matrix_.d, matrix_.tx, matrix_.ty );			}		}		//---------		// SCALING		//---------		/**		 * Function for getting X scale of transform Matrix.		 * @return Number The X scale of transform Matrix.		 */		public function get scaleX( ):Number		{			return Math.sqrt( Math.pow( a, 2 ) + Math.pow( b, 2 ) );		}		/**		 * @private		 * Function for setting X scale of transform Matrix.		 * @param setScaleX_ Number The X scale amount to use.		 */		public function set scaleX( setScaleX_:Number ):void		{			var oldValue:Number = scaleX;			if ( oldValue )			{				var ratio:Number = setScaleX_ / oldValue;				a *= ratio;				b *= ratio;			}			else			{				var ySkewR:Number = skewYR;				a = Math.cos( ySkewR ) * setScaleX_;				b = Math.sin( ySkewR ) * setScaleX_;			}		}		/**		 * Function for getting Y scale of transform Matrix.		 * @return Number The Y scale of transform Matrix.		 */		public function get scaleY( ):Number		{			return Math.sqrt( Math.pow( c, 2 ) + Math.pow( d, 2 ) );		}		/**		 * @private		 * Function for setting Y scale of transform Matrix.		 * @param setScaleY_ Number The Y scale amount to use.		 */		public function set scaleY( setScaleY_:Number ):void		{			var oldValue:Number = scaleY;			if ( oldValue )			{				var ratio:Number  = setScaleY_ / oldValue;				c *= ratio;				d *= ratio;			}			else			{				var xSkewR:Number = skewXR;				c = - Math.sin( xSkewR ) * setScaleY_;				d =   Math.cos( xSkewR ) * setScaleY_;			}		}		/**		 * Function for scaling the matrix from a Point.		 * @param origoX_ Number X coordinate of point to scale from.		 * @param origoY_ Number Y coordinate of point to scale from.		 * @param scale_ Number The scale amount to use.		 * @param internalOrigo_ Boolean If true, point will be transformed to Matrix's coordinate space.		 */		public function origoScale( origoX_:Number, origoY_:Number, scale_:Number, internalOrigo_:Boolean = true ):void		{			var point:Point  = new Point( origoX_, origoY_ );			if ( internalOrigo_ )			{				point = transformPoint( point );			}			tx -= point.x;			ty -= point.y;			scaleX = scale_;			scaleY = scale_;			tx += point.x;			ty += point.y;		}		//---------		// SKEWING		//---------		/**		 * Function for getting skew X component in radians.		 * @return Number The X component of skew value in radians.		 */		public function get skewXR( ):Number		{			return Math.atan2( -c, d );		}		/**		 * @private		 * Function for setting skew X component in radians.		 * @param setSkewX_ Number The X component of skew value in radians.		 */		public function set skewXR( setSkewX_:Number ):void		{			var yScale:Number = scaleY;			c = - yScale * Math.sin( setSkewX_ );			d =   yScale * Math.cos( setSkewX_ );		}		/**		 * Function for getting skew X component in angles.		 * @return Number The X component of skew value in angles.		 */		public function get skewX( ):Number		{			return skewXR * Trigonometry.RADS_TO_ANGLE;		}		/**		 * @private		 * Function for setting skew X component in angles.		 * @param setSkewX_ Number The X component of skew value in angles.		 */		public function set skewX( setSkewX_:Number ):void		{			skewXR = setSkewX_ * Trigonometry.ANGLE_TO_RADS;		}		/**		 * Function for getting skew Y component in radians.		 * @return Number The Y component of skew value in radians.		 */		public function get skewYR( ):Number		{			return Math.atan2( b, a );		}		/**		 * @private		 * Function for setting skew Y component in radians.		 * @param setSkewY_ Number The Y component of skew value in radians.		 */		public function set skewYR( setSkewY_:Number ):void		{			var xScale:Number = scaleX;			a = xScale * Math.cos( setSkewY_ );			b = xScale * Math.sin( setSkewY_ );		}		/**		 * Function for getting skew Y component in angles.		 * @return Number The Y component of skew value in angles.		 */		public function get skewY( ):Number		{			return skewYR * Trigonometry.RADS_TO_ANGLE;		}		/**		 * @private		 * Function for setting skew Y component in angles.		 * @param setSkewY_ Number The Y component of skew value in angles.		 */		public function set skewY( setSkewY_:Number ):void		{			skewYR = setSkewY_ * Trigonometry.ANGLE_TO_RADS;		}		//----------		// ROTATION		//----------		/**		 * Function for getting rotation of transform Matrix in radians.		 * @return Number The rotation of transform Matrix in radians.		 */		public function get rotationR( ):Number		{			return skewYR;		}		/**		 * @private		 * Function for setting rotation of transform Matrix in radians.		 * @param setRotation_ Number The rotation of transform Matrix in radians.		 */		public function set rotationR( setRotation_:Number ):void		{			var oldRotation:Number = rotationR;			var oldSkewX:Number    = skewXR;			var oldSkewY:Number    = skewYR;			skewXR = oldSkewX + setRotation_ - oldRotation;			skewYR = oldSkewY + setRotation_ - oldRotation;		}		/**		 * Function for getting rotation of transform Matrix in angles.		 * @return Number The rotation of transform Matrix in angles.		 */		public function get rotation( ):Number		{			return rotationR * Trigonometry.RADS_TO_ANGLE;		}		/**		 * @private		 * Function for setting rotation of transform Matrix in angles.		 * @param setRotation_ Number The rotation of transform Matrix in angles.		 */		public function set rotation( setRotation_:Number ):void		{			rotationR = setRotation_ * Trigonometry.ANGLE_TO_RADS;		}		/**		 * Function for rotating the matrix around a Point.		 * @param origoX_ Number X coordinate of point to rotate around.		 * @param origoY_ Number Y coordinate of point to rotate around.		 * @param angleDegrees_ Number The rotation amount in angles.		 * @param internalOrigo_ Boolean If true, point will be transformed to Matrix's coordinate space.		 */		public function origoRotate( origoX_:Number, origoY_:Number, angleDegrees_:Number, internalOrigo_:Boolean = true ):void		{			var point:Point  = new Point( origoX_, origoY_ );			if ( internalOrigo_ )			{				point = transformPoint( point );			}			tx -= point.x;			ty -= point.y;			rotation = angleDegrees_;			tx += point.x;			ty += point.y;		}		//----------		// POSITION		//----------		/**		 * Function for getting the X translation of the Matrix.		 * @return Number The X translation of the Matrix.		 */		public function get x( ):Number		{			return tx;		}		/**		 * @private		 * Function for setting the X translation of the Matrix.		 * @param setX_ Number The X translation of the Matrix.		 */		public function set x( setX_:Number ):void		{			tx = setX_;		}		/**		 * Function for getting the Y translation of the Matrix.		 * @return Number The Y translation of the Matrix.		 */		public function get y( ):Number		{			return ty;		}		/**		 * @private		 * Function for setting the X translation of the Matrix.		 * @param setY_ Number The X translation of the Matrix.		 */		public function set y( setY_:Number ):void		{			ty = setY_;		}		/**		 * Moves the Matrix the way, that an internal point will cover an external one.		 * @param internalPoint_ Point The internal point to use as reference.		 * @param externalPoint_ Point The external Point to be covered by the internal one.		 */		public function matchInternalExternal( internalPoint_:Point, externalPoint_:Point ):void		{			var internalPointTransformed:Point = transformPoint( internalPoint_ );			var dx:Number                      = externalPoint_.x - internalPointTransformed.x;			var dy:Number                      = externalPoint_.y - internalPointTransformed.y;			tx += dx;			ty += dy;		}	}}