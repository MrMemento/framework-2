/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.debug.sampling{	import flash.utils.Timer;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.sampler.NewObjectSample;	import flash.sampler.DeleteObjectSample;	import flash.sampler.getSize;	import com.memento.utils.ClassUtil;	import com.memento.core.singleton.SingletonCollector;	import com.memento.events.dispatchers.SingletonDispatcher;	import com.memento.debug.sampling.SampleCollector;	/**	 * Event dispatched when statistics get updated.	 * @eventType flash.events.Event.CHANGE	 */	[ Event( name = 'change', type = 'flash.events.Event' ) ]	/**	 * SINGLETON Class for tracking procedure.	 * @see com.memento.debug.sampling.SampleCollector	 * @author Barnabás Bucsy (Lobo)	 */	public class MemorySampler extends SingletonDispatcher	{		/**		 * Default sampling delay in milliseconds.		 */		public static var DEFAULT_DELAY:uint = 1000;		/**		 * SampleCollector instance.		 */		private var _collector:SampleCollector;		/**		 * Timer to ensure intervals.		 */		private var _timer:Timer;		/**		 * Flag indicating sampling in progress.		 */		private var _running:Boolean;		/**		 * Container for objects.		 */		private var _objects:Object;		/**		 * Container for statistics.		 */		private var _statistics:Object;		/**		 * Constructor		 * @delay_ uint Processing delay in milliseconds.		 */		public function MemorySampler( ):void		{			_collector  = SingletonCollector.get( SampleCollector );			_running    = false;			_objects    = { };			_statistics = { };			_timer      = new Timer( DEFAULT_DELAY );			_timer.addEventListener( TimerEvent.TIMER, process );		}		/**		 * Starts sampling.		 */		public function start( ):void		{			if ( !_running )			{				_timer.start( );				_collector.start( );			}			_running = true;		}		/**		 * Stops sampling.		 */		public function stop( ):void		{			if ( _running )			{				_timer.stop( );				_collector.stop( );			}			_running = false;		}		/**		 * Processes SampleCollector data based on interval.		 * @ event_ TimerEvent Intervaled Timer event.		 */		private function process( event_:TimerEvent ):void		{			_collector.pause( );			var size:uint;			var className:String;			var samples:Object = _collector.samples;			for each ( var sample:Object in samples )			{				if ( sample is NewObjectSample )				{					if ( sample.object == null )					{						continue;					}					className = ClassUtil.getClassName( sample.type );					size      = getSize( sample.object );					if ( !_objects.hasOwnProperty( sample.id ) )					{						_objects[ sample.id ] = { };					}					_objects[ sample.id ].type = className;					_objects[ sample.id ].size = size					if ( !_statistics.hasOwnProperty( className ) )					{						_statistics[ className ] = {							count: 0,							size:  0						};					}					_statistics[ className ].count++;					_statistics[ className ].size += size;				}				else if ( sample is DeleteObjectSample )				{					if ( !_objects.hasOwnProperty( sample.id ) )					{						continue;					}					className = _objects[ sample.id ].type;					size      = _objects[ sample.id ].size;					delete _objects[ sample.id ];					if ( !_statistics.hasOwnProperty( className ) )					{						continue;					}					_statistics[ className ].count--;					_statistics[ className ].size -= size;				}			}			dispatchEvent( new Event( Event.CHANGE ) );			_collector.resume( );		}		/**		 * Getter function for whether the instance is collecting data.		 * @return Boolean Is the instance collecting data.		 */		public function get running( ):Boolean		{			return _running;		}		/**		 * Getter function for the collection delay.		 * @return uint The collection delay.		 */		public function get delay( ):uint		{			return _timer.delay;		}		/**		 * @private		 * Setter function for the collection delay.		 * @param uint The collection delay.		 */		public function set delay( delay_:uint ):void		{			_timer.delay = delay_;		}		/**		 * Getter function for sampled objects.		 */		public function get objects( ):Object		{			return _objects;		}		/**		 * Getter function for sampled statistics.		 */		public function get statistics( ):Object		{			return _statistics;		}		/**		 * Getter function whether sampling is available.		 * @return Boolean Is sampling available.		 */		public static function get AVAILABLE( ):Boolean		{			return SampleCollector.AVAILABLE;		}	}}/** * Original code is part of the Spark project, called FlaProfiler by anthill: * http://www.libspark.org/ * * --------------------------------------------------------------------------------- *  ORIGINAL CODE LICENSE * --------------------------------------------------------------------------------- * * The MIT License * Copyright (c) 2009 ants Inc. * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */