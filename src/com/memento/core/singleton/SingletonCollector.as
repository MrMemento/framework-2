/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.core.singleton{	import com.memento.utils.ClassUtil;	import com.memento.core.singleton.ISingletonable;	/**	 * STATIC Class for collecting singleton instances.	 * @author Barnabás Bucsy (Lobo)	 */	public class SingletonCollector	{		/**		 * Object for collecting singleton instances.		 */		private static var __instances:Object = { };		/**		 * Static flag telling currently instantiated ISingletonable		 * to register itself back to SingletonCollector.		 */		private static var __currentInstantiation:String = null;		/**		 * Constructor		 * @throws Error Static Class.		 */		public function SingletonCollector( ):void		{			throw new Error( 'Tried to instantiate static class!' );		}		/**		 * Static function for getting singleton instances.		 * @param Class_ Class Class of singleton to get. Class_ must be a subclass of ISingletonable.		 * @return * The singleton instance of Class_.		 * @throws Error Throws Error, if Class_ is not a subclass of ISingletonable.		 */		public static function get( Class_:Class ):*		{			var ref:String = ClassUtil.getClassName( Class_ );			if ( !__instances[ ref ] )			{				// ISingletonable will register itself back to SingletonCollector				// at instantiastion time based on CURRENT_INSTANTIATION's value.				// This way we can use the singletons before they are being saved				// by SingletonCollector (eg. in descendant's constructor).				if ( !Class_ is ISingletonable )				{					throw new Error( 'Tried to instantiate non ISingletonable instance: ' + ref );				}				__currentInstantiation = ref;				new Class_( );				__currentInstantiation = null;			}			return __instances[ ref ] as Class_;		}		/**		 * Function for registering newly created ISingletonable descendants.		 * @param model_ ISingletonable ISingletonable descendant to register.		 * @throws Error Throws error if instance already registered.		 */		public static function register( model_:ISingletonable ):void		{			if ( __instances[ model_.className ] )			{				throw new Error( 'Tried to re-register ISingletonable: ' + model_.className );			}			__instances[ model_.className ] = model_;		}		/**		 * Getter function for name of currently instantiated ISingletonable's name.		 * @return String Class name of currently instantiated ISingletonable.		 */		public static function get CURRENT_INSTANTIATION( ):String		{			return __currentInstantiation;		}	}}