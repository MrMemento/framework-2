/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.utils{	import com.memento.core.regexp.StaticRegExpUser;	import com.memento.core.date.DateDiff;	import com.memento.utils.NumberUtil;	import com.memento.constants.patterns.DateReplacePatterns;	/**	 * STATIC Class for managing Dates in ActionScript.	 * @author Barnabás Bucsy (Lobo)	 */	public class DateUtil extends StaticRegExpUser	{		/**		 * Constant for separator to be used with fancy timestamps.		 */		public static const DOT_SEPARATOR:String = '.';		/**		 * Constant for separator to be used with fancy timestamps.		 */		public static const COLON_SEPARATOR:String = ':';		/**		 * Constant for separator to be used with safe timestamps.		 */		public static const SAFE_SEPARATOR:String = '_';		/**		 * Months of year.		 */		public static var MONTHS:Array = [			'January',		'February',	'March',	'April',			'May',			'June',		'July',		'August',			'September',	'October',	'November',	'December'		];		/**		 * Months of year (short).		 */		public static var MONTHS_SHORT:Array = [			'Jan',	'Feb',	'Mar',	'Apr',			'May',	'Jun',	'Jul',	'Aug',			'Sep',	'Oct',	'Nov',	'Dec'		];		/**		 * Days of week.		 */		public static var DAYS:Array = [			'Sunday',	'Monday',	'Tuesday',	'Wednesday',			'Thursday',	'Friday',	'Saturday'		];		/**		 * Days of week (short).		 */		public static var DAYS_SHORT:Array = [			'Sun',	'Mon',	'Tue',	'Wed',			'Thu',	'Fri',	'Sat'		];		/**		 * Ante Meridiem.		 */		public static var AM:String = 'AM';		/**		 * Post Meridiem.		 */		public static var PM:String = 'PM';		/**		 * Ante Meridiem lowercase.		 */		public static var AM_LOWER:String = 'am';		/**		 * Post Meridiem lowercase.		 */		public static var PM_LOWER:String = 'pm';		/**		 * Default print pattern for printDate() function.		 * @see com.memento.constants.patterns.DateReplacePatterns		 */		public static var DEFAULT_PRINT_PATTERN:String = 'Y, m. #d. (d) H:i';		/**		 * Holder for Date to use while replacing with printDate() function.		 */		private static var __date:Date;		/**		 * Constructor		 * @throws Error Static Class.		 */		public function DateUtil( ):void		{			throw new Error( 'Tried to instantiate static class!' );		}		/**		 * Calculates the difference between two Dates.		 * @param date0_ Date Start Date.		 * @param date1_ Date End Date.		 * @return DateDiff Difference of the two Dates.		 * @see com.memento.data.date.DateDiff		 */		public static function diff( date0_:Date, date1_:Date ):DateDiff		{			return new DateDiff( date1_.getTime( ) - date0_.getTime( ) );		}		/**		 * Returns a formatted timestamp String.		 * This is a much faster way than using printDate()!		 * @param safe_ Whether to use "." and ":" characters or just "_".		 * @param useUTC_ Whether to use UTC or local time.		 * @return String The formatted timestamp String.		 */		public static function timestamp( safe_:Boolean = false, useUTC_:Boolean = true ):String		{			var d:Date = new Date( );			if ( safe_ )			{				if ( useUTC_ )				{					return d.getUTCFullYear( )                          +						NumberUtil.toFixedPlaces( d.getUTCMonth( ) +1 ) +						NumberUtil.toFixedPlaces( d.getUTCDate( ) )     + SAFE_SEPARATOR +						NumberUtil.toFixedPlaces( d.getUTCHours( ) )    +						NumberUtil.toFixedPlaces( d.getUTCMinutes( ) )  +						NumberUtil.toFixedPlaces( d.getUTCSeconds( ) )  + SAFE_SEPARATOR +						NumberUtil.toFixedPlaces( d.getUTCMilliseconds( ), 3 );				}				else				{					return d.getFullYear( )                          +						NumberUtil.toFixedPlaces( d.getMonth( ) +1 ) +						NumberUtil.toFixedPlaces( d.getDate( ) )     + SAFE_SEPARATOR +						NumberUtil.toFixedPlaces( d.getHours( ) )    +						NumberUtil.toFixedPlaces( d.getMinutes( ) )  +						NumberUtil.toFixedPlaces( d.getSeconds( ) )  + SAFE_SEPARATOR +						NumberUtil.toFixedPlaces( d.getMilliseconds( ), 3 );				}			}			else			{				if ( useUTC_ )				{					return d.getUTCFullYear( )                          + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getUTCMonth( ) +1 ) + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getUTCDate( ) )     + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getUTCHours( ) )    + COLON_SEPARATOR +						NumberUtil.toFixedPlaces( d.getUTCMinutes( ) )  + COLON_SEPARATOR +						NumberUtil.toFixedPlaces( d.getUTCSeconds( ) )  + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getUTCMilliseconds( ), 3 );				}				else				{					return d.getFullYear( )                          + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getMonth( ) +1 ) + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getDate( ) )     + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getHours( ) )    + COLON_SEPARATOR +						NumberUtil.toFixedPlaces( d.getMinutes( ) )  + COLON_SEPARATOR +						NumberUtil.toFixedPlaces( d.getSeconds( ) )  + DOT_SEPARATOR   +						NumberUtil.toFixedPlaces( d.getMilliseconds( ), 3 );				}			}		}		/**		 * Checks if a full year is a leap year.		 * @param year_ uint Full year to check.		 * @return Boolean Is the full year a leap year.		 */		public static function isLeapYear( year_:uint ):Boolean		{			return ( ( year_ %4 == 0 ) && ( year_ %100 != 0 ) ) || ( year_ %400 == 0 );		}		/**		 * Creates a String representing the given Date.		 * @param date_ Date The Date to print. If null, current Date will be used.		 * @param pattern_ String The pattern String on which printing will be based. If null, default pattern will be used.		 * @param UTC_ Boolean Whether to use UTC Date.		 * @return String String representation of the Date.		 */		public static function printDate( date_:Date = null, pattern_:String = null, UTC_:Boolean = false ):String		{			__date = date_ || new Date( );			if ( pattern_ == null )			{				pattern_ = DEFAULT_PRINT_PATTERN;			}			fetchCollector( );			// manage patterns			pattern_ = pattern_.replace(				__collector.get( DateReplacePatterns.ALL_PATTERNS, true ),				UTC_ ? manageUTCPrintPattern : managePrintPattern			);			__date = null;			// unescape escaped characters			return pattern_.replace(				__collector.get( DateReplacePatterns.ESCAPED_PATTERNS, true ),				'$1'			);		}		/**		 * Private function for replacing patterns with printDate() function.		 * @param pattern_ String The match to format.		 * @param ...args_ Array Rest parameter for sub-matches.		 * @return String The formatted Date String.		 */		private static function managePrintPattern( pattern_:String, ...args_:Array ):String		{			pattern_ = pattern_.substr( 0, 2 );			var m:uint;			var c:uint;			switch ( pattern_ )			{				case DateReplacePatterns.FULL_YEAR:					return __date.getFullYear( ).toString( );				case DateReplacePatterns.SHORT_YEAR:					return __date.getFullYear( ).toString( ).substr( 2 );				case DateReplacePatterns.MONTH:					return MONTHS[ __date.getMonth( ) ];				case DateReplacePatterns.MONTH_SHORT:					return MONTHS_SHORT[ __date.getMonth( ) ];				case DateReplacePatterns.MONTH_NUMERIC:					c = parseInt( args_[ 0 ] );					m = __date.getMonth( );					if ( !isNaN( c ) && c != 0 )					{						return NumberUtil.toFixedPlaces( m, c );					}					return m.toString( );				case DateReplacePatterns.DAY:					return DAYS[ __date.getDay( ) ];				case DateReplacePatterns.DAY_SHORT:					return DAYS_SHORT[ __date.getDay( ) ];				case DateReplacePatterns.DAY_NUMERIC:					c = parseInt( args_[ 1 ] );					m = __date.getDay( );					if ( !isNaN( c ) && c != 0 )					{						return NumberUtil.toFixedPlaces( m, c );					}					return m.toString( );				case DateReplacePatterns.HOURS:					return NumberUtil.toFixedPlaces( __date.getHours( ), 2 );				case DateReplacePatterns.HOURS_12:					return NumberUtil.toFixedPlaces( __date.getHours( ) == 0 ? 12 : __date.getHours( ) %12, 2 );				case DateReplacePatterns.MINUTES:					return NumberUtil.toFixedPlaces( __date.getMinutes( ), 2 );				case DateReplacePatterns.SECONDS:					return NumberUtil.toFixedPlaces( __date.getSeconds( ), 2 );				case DateReplacePatterns.MILLISECONDS:					return NumberUtil.toFixedPlaces( __date.getMilliseconds( ), 3 );				case DateReplacePatterns.AMPM:					return __date.getHours( ) == 0 || __date.getHours( ) > 11 ? PM_LOWER : AM_LOWER;				case DateReplacePatterns.AMPM_UPPER:					return __date.getHours( ) == 0 || __date.getHours( ) > 11 ? PM : AM;				case DateReplacePatterns.WEEK:					return getWeekNumber( __date ).toString( );				default:					return pattern_;			}		}		/**		 * Private function for replacing patterns with printDate() function using UTC.		 * @param pattern_ String The match to format.		 * @param ...args_ Array Rest parameter for sub-matches.		 * @return String The formatted Date String.		 */		private static function manageUTCPrintPattern( pattern_:String, ...args_:Array ):String		{			pattern_ = pattern_.substr( 0, 2 );			var m:uint;			var c:uint;			switch ( pattern_ )			{				case DateReplacePatterns.FULL_YEAR:					return __date.getUTCFullYear( ).toString( );				case DateReplacePatterns.SHORT_YEAR:					return __date.getUTCFullYear( ).toString( ).substr( 2 );				case DateReplacePatterns.MONTH:					return MONTHS[ __date.getUTCMonth( ) ];				case DateReplacePatterns.MONTH_SHORT:					return MONTHS_SHORT[ __date.getUTCMonth( ) ];				case DateReplacePatterns.MONTH_NUMERIC:					c = parseInt( args_[ 0 ] );					m = __date.getUTCMonth( ) +1;					if ( !isNaN( c ) && c != 0 )					{						return NumberUtil.toFixedPlaces( m, c );					}					return m.toString( );				case DateReplacePatterns.DAY:					return DAYS[ __date.getUTCDay( ) ];				case DateReplacePatterns.DAY_SHORT:					return DAYS_SHORT[ __date.getUTCDay( ) ];				case DateReplacePatterns.DAY_NUMERIC:					c = parseInt( args_[ 1 ] );					m = __date.getUTCDay( );					if ( !isNaN( c ) && c != 0 )					{						return NumberUtil.toFixedPlaces( m, c );					}					return m.toString( );				case DateReplacePatterns.HOURS:					return NumberUtil.toFixedPlaces( __date.getUTCHours( ), 2 );				case DateReplacePatterns.HOURS_12:					return NumberUtil.toFixedPlaces(  __date.getUTCHours( ) == 0 ? 12 : __date.getUTCHours( ) %12, 2 );				case DateReplacePatterns.MINUTES:					return NumberUtil.toFixedPlaces( __date.getUTCMinutes( ), 2 );				case DateReplacePatterns.SECONDS:					return NumberUtil.toFixedPlaces( __date.getUTCSeconds( ), 2 );				case DateReplacePatterns.MILLISECONDS:					return NumberUtil.toFixedPlaces( __date.getUTCMilliseconds( ), 3 );				case DateReplacePatterns.AMPM:					return __date.getUTCHours( ) == 0 || __date.getUTCHours( ) > 11 ? PM_LOWER : AM_LOWER;				case DateReplacePatterns.AMPM_UPPER:					return __date.getUTCHours( ) == 0 || __date.getUTCHours( ) > 11 ? PM : AM;				case DateReplacePatterns.WEEK:					return getWeekNumber( __date, true ).toString( );				default:					return pattern_;			}		}		/**		 * Calculates ISO 8601 week number. Can be last year's last or next year's first week.		 * Week 1 of a given year is the one that includes the first Thursday of that year (or,		 * equivalently, week 1 is the week that includes 4 January).		 * @param date_ Date The Date of which the week number should be extracted from.		 * @param UTC_ Boolean Whether to use UTC Date.		 * @return uint The week number of the given Date.		 */		public static function getWeekNumber( date_:Date = null, UTC_:Boolean = false ):uint		{			if ( date_ === null )			{				date_ = new Date( );			}			var a:int;			var b:int;			var c:int;			var d:int;			var e:int;			var f:int;			var g:int;			var s:int;			var n:int;			var m:int = ( UTC_ ? date_.getUTCMonth( ) : date_.getMonth( ) ) +1;			if ( m < 2 )			{				a = ( UTC_ ? date_.getUTCFullYear( ) : date_.getFullYear( ) ) -1;				b = Math.floor( a *0.25 ) - Math.floor( a *0.01 ) + Math.floor( a *0.0025 );				c = a -1;				c = Math.floor( c *0.25 ) - Math.floor( c *0.01 ) + Math.floor( c *0.0025 );				s = b - c;				e = 0;				f = ( UTC_ ? date_.getUTCDate( ) : date_.getDate( ) ) -1 + m *31;			}			else			{				a = ( UTC_ ? date_.getUTCFullYear( ) : date_.getFullYear( ) );				b = Math.floor( a *0.25 ) - Math.floor( a *0.01 ) + Math.floor( a *0.0025 );				c = a -1;				c = Math.floor( c *0.25 ) - Math.floor( c *0.01 ) + Math.floor( c *0.0025 );				s = b - c;				e = s +1;				f = s + ( UTC_ ? date_.getUTCDate( ) : date_.getDate( ) ) + Math.floor( ( ( m -3 ) *153 +2 ) *0.2 ) +58;			}			g = ( a + b ) %7;			d = ( f + g - e ) % 7;			n = f - d +3;			if ( n < 0 )			{				return 53 - Math.floor( ( g - s ) *0.2 );			}			else if ( n > s +364 )			{				return 1;			}			else			{				return Math.floor( n /7 ) +1;			}		}	}}