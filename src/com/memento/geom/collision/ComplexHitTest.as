/** * Copyright 2011 by Barnabás Bucsy * * This file is part of The Memento Framework. * * The Memento Framework is free software: you can redistribute it * and/or modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. * * The Memento Framework is distributed in the hope that it will be * useful, but WITHOUT ANY WARRANTY; without even the implied warranty * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with The Memento Framework. If not, see * <http://www.gnu.org/licenses/>. */package com.memento.geom.collision{	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * STATIC Class for complex hittest of DisplayObjects.	 * @author Barnabás Bucsy (Lobo)	 */	public class ComplexHitTest	{		/**		 * Constructor		 * @throws Error Static Class.		 */		public function ComplexHitTest( ):void		{			throw new Error( 'Tried to intsantiate static class!');		}		/**		 * Checks two DisplayObjects' collision with given accuracy.		 * @param target1_ DisplayObject DisplayObject to test.		 * @param target2_ DisplayObject DisplayObject to test.		 * @param accuracy_ Number Accuracy to use when testing. Must be bigger than zero.		 * @return Boolean Do the two DisplayObjects collide.		 */		public static function complexHitTestObject( target1_:DisplayObject, target2_:DisplayObject, accuracy_:Number = 1 ):Boolean		{			return complexIntersectionRectangle( target1_, target2_, accuracy_ ).width != 0;		}		/**		 * Find the intersection of two DisplayObjects based on their bounds.		 * @param target1_ DisplayObject DisplayObject to test.		 * @param target2_ DisplayObject DisplayObject to test.		 * @return Rectangle The intersection rectangle of the two DisplayObjects.		 */		public static function intersectionRectangle( target1_:DisplayObject, target2_:DisplayObject ):Rectangle		{			// If either of the items don't have a reference to stage, then they are not in a display list			// or if a simple hitTestObject is false, they cannot be intersecting.			if ( !target1_.root || !target2_.root || !target1_.hitTestObject( target2_ ) )			{				return new Rectangle( );			}			// Get the bounds of each DisplayObject.			var bounds1:Rectangle = target1_.getBounds( target1_.root );			var bounds2:Rectangle = target2_.getBounds( target2_.root );			// Determine test area boundaries.			var intersection:Rectangle = new Rectangle();			intersection.x             = Math.max( bounds1.x, bounds2.x );			intersection.y             = Math.max( bounds1.y, bounds2.y );			intersection.width         = Math.min( ( bounds1.x + bounds1.width )  - intersection.x, ( bounds2.x + bounds2.width )  - intersection.x );			intersection.height        = Math.min( ( bounds1.y + bounds1.height ) - intersection.y, ( bounds2.y + bounds2.height ) - intersection.y );			return intersection;		}		/**		 * Find the complex intersection of two DisplayObjects.		 * @param target1_ DisplayObject DisplayObject to test.		 * @param target2_ DisplayObject DisplayObject to test.		 * @param accuracy_ Number Accuracy to use when testing. Must be bigger than zero.		 * @return Rectangle The complex intersection rectangle of the two DisplayObjects.		 * @throws Error Throws Error if accuracy_ is smaller than zero.		 */		public static function complexIntersectionRectangle( target1_:DisplayObject, target2_:DisplayObject, accuracy_:Number = 1 ):Rectangle		{			if ( accuracy_ <= 0 )			{				throw new Error( 'Invalid value for accuracy.' );			}			var hitRectangle:Rectangle = intersectionRectangle( target1_, target2_ );			// If their boundaries are not interesecting, they can not be intersecting.			if ( hitRectangle.width * accuracy_ < 1 || hitRectangle.height * accuracy_ < 1 )			{				return new Rectangle( );			}			var bitmapData:BitmapData = new BitmapData(				hitRectangle.width  * accuracy_,				hitRectangle.height * accuracy_,				false,				0x000000			);			// Draw the first target.			bitmapData.draw(				target1_,				ComplexHitTest.getDrawMatrix( target1_, hitRectangle, accuracy_ ),				new ColorTransform( 1, 1, 1, 1, 255, -255, -255, 255 )			);			// Overlay the second target.			bitmapData.draw(				target2_,				ComplexHitTest.getDrawMatrix( target2_, hitRectangle, accuracy_ ),				new ColorTransform( 1, 1, 1, 1, 255, 255, 255, 255 ),				BlendMode.DIFFERENCE			);			// Find the intersection.			var intersection:Rectangle = bitmapData.getColorBoundsRect( 0xFFFFFFFF,0xFF00FFFF );			bitmapData.dispose( );			// Alter width and positions to compensate for accuracy			if ( accuracy_ != 1 )			{				intersection.x      /= accuracy_;				intersection.y      /= accuracy_;				intersection.width  /= accuracy_;				intersection.height /= accuracy_;			}			intersection.x += hitRectangle.x;			intersection.y += hitRectangle.y;			return intersection;		}		/**		 * Function for generating Matrix to be used with BitmapData.draw() method.		 * @param target_ DisplayObject Target DisplayObject to draw.		 * @param hitRectangle_ Rectangle Rectangle of collision to observe.		 * @param accuracy_ Number Accuracy to use when testing. Must be bigger than zero.		 * @return Matrix The Matrix to use when drawing to the BitmapData.		 */		private static function getDrawMatrix( target_:DisplayObject, hitRectangle_:Rectangle, accuracy_:Number ):Matrix		{			var localToGlobal:Point;			var matrix:Matrix;			var rootConcatenatedMatrix:Matrix = target_.root.transform.concatenatedMatrix;			localToGlobal = target_.localToGlobal( new Point( ) );			matrix        = target_.transform.concatenatedMatrix;			matrix.tx     = localToGlobal.x - hitRectangle_.x;			matrix.ty     = localToGlobal.y - hitRectangle_.y;			matrix.a = matrix.a / rootConcatenatedMatrix.a;			matrix.d = matrix.d / rootConcatenatedMatrix.d;			if ( accuracy_ != 1 )			{				matrix.scale( accuracy_, accuracy_ );			}            return matrix;		}	}}/** * Rewritten code found at Tink blog run by Stephen Downs: * http://www.tink.ws/blog/as-30-hittest/ * The base of his work was Grant Skinner's GTWeen. * * --------------------------------------------------------------------------------- *  ORIGINAL CODE LICENSE * --------------------------------------------------------------------------------- * * GTween by Grant Skinner. Aug 1, 2005 * Visit www.gskinner.com/blog for documentation, updates and more free code. * Copyright (c) 2005 Grant Skinner * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the "Software"), to deal in the Software without * restriction, including without limitation the rights to use, * copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following * conditions: * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. */